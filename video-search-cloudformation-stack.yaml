AWSTemplateFormatVersion: '2010-09-09'
Description: |
  Condenast Video Search Infrastructure Stack
  
  IMPORTANT DEPLOYMENT NOTES:
  - OpenSearch domain creation takes 15-20 minutes. Stack will wait for completion.
  - Lambda functions require VPC endpoints for S3, ECR, Bedrock, and STS access (all included).
  - ECS tasks pull images from ECR via VPC endpoints (no internet access required).
  - Step Functions automatically invoke Lambda functions via resource-based policies (included).
  - All IAM roles follow least-privilege principle with app-scoped OpenSearch roles.
  - Custom resource Lambda configures OpenSearch FGAC role mappings during stack creation.
  - REQUIRED: Lambda layer ZIP files must exist in S3 before deployment:
    * s3://{env}-aihouse-dist-{AccountId}/lambda-artifacts/opensearch-query-dependencies-2fb22b80-caf2-4d3f-84a6-3f863bf3c409.zip
    * s3://{env}-aihouse-dist-{AccountId}/lambda-artifacts/ffmpeg-video-processing-dependencies-697fac5e-fb3f-4814-b610-f0d2d3812616.zip

Parameters:
  env:
    Type: String
    Default: 'local'
    AllowedValues: ['local', 'dev', 'staging', 'prod']
    Description: 'Environment name for resource naming (local, dev, staging, prod)'
  StackPrefix:
    Type: String
    Default: 'vs-1'
    Description: 'Prefix for all resource names to avoid collisions (Max. - 8 characters)'
    AllowedPattern: '[a-zA-Z0-9-]+'
    MaxLength: 8

Mappings:
  BucketNames:
    Video:
      BaseName: 'videos'
    Frontend:
      BaseName: 'aihouse-dist'

Resources:
  ECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${StackPrefix}-${env}-ecs-task-execution-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: ECRAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                Resource: '*'
        - PolicyName: CloudWatchLogs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/ecs/${StackPrefix}-${env}-video-preprocessing:*'
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/ecs/${StackPrefix}-${env}-search-similar-videos-task:*'

  ECSTaskRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${StackPrefix}-${env}-ecs-task-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource: !Sub 
                  - 'arn:aws:s3:::${VideoBucket}-${AWS::Region}-${AWS::AccountId}-${env}/*'
                  - VideoBucket: !FindInMap [BucketNames, Video, BaseName]
              - Effect: Allow
                Action:
                  - s3:PutObject
                Resource: !Sub 
                  - 'arn:aws:s3:::${VideoBucket}-${AWS::Region}-${AWS::AccountId}-${env}/*'
                  - VideoBucket: !FindInMap [BucketNames, Video, BaseName]
              - Effect: Allow
                Action:
                  - s3:ListBucket
                Resource:
                  - !Sub 
                    - 'arn:aws:s3:::${VideoBucket}-${AWS::Region}-${AWS::AccountId}-${env}'
                    - VideoBucket: !FindInMap [BucketNames, Video, BaseName]
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                  - s3:ListBucket
                Resource: 
                  - !Sub 'arn:aws:s3:::processed-videos-${AWS::Region}-${AWS::AccountId}-${env}'
                  - !Sub 'arn:aws:s3:::processed-videos-${AWS::Region}-${AWS::AccountId}-${env}/*'
        - PolicyName: StepFunctionsAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - states:SendTaskSuccess
                  - states:SendTaskFailure
                Resource: '*'

  SearchSimilarVideosTaskRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${StackPrefix}-${env}-search-similar-videos-ecs-task-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: OpenSearchAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: OpenSearchAccess
                Effect: Allow
                Action:
                  - es:ESHttpGet
                  - es:ESHttpPost
                  - es:ESHttpPut
                  - es:ESHttpDelete
                  - es:ESHttpHead
                Resource:
                  - !Sub 'arn:aws:es:${AWS::Region}:${AWS::AccountId}:domain/${StackPrefix}-${env}-aos/*'
        - PolicyName: BedrockInvokeModel
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: BedrockInvokeModel
                Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource:
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:inference-profile/*'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/us.twelvelabs.marengo-embed-2-7-v1:0'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/twelvelabs.marengo-embed-2-7-v1:0'
                  - arn:aws:bedrock:us-east-2::foundation-model/twelvelabs.marengo-embed-2-7-v1:0
                  - arn:aws:bedrock:us-west-2::foundation-model/twelvelabs.marengo-embed-2-7-v1:0
                  - arn:aws:bedrock:us-west-1::foundation-model/twelvelabs.marengo-embed-2-7-v1:0
                  - !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/us.twelvelabs.marengo-embed-3-0-v1:0'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/twelvelabs.marengo-embed-3-0-v1:0'
                  - arn:aws:bedrock:us-east-2::foundation-model/twelvelabs.marengo-embed-3-0-v1:0
                  - arn:aws:bedrock:us-west-2::foundation-model/twelvelabs.marengo-embed-3-0-v1:0
                  - arn:aws:bedrock:us-west-1::foundation-model/twelvelabs.marengo-embed-3-0-v1:0
                  - !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/amazon.nova-micro-v1:0'
        - PolicyName: S3ReadAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: S3ReadAccess
                Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:GetObjectVersion
                  - s3:ListBucket
                  - s3:PutObject
                Resource:
                  - !Sub 
                    - 'arn:aws:s3:::${VideoBucket}-${AWS::Region}-${AWS::AccountId}-${env}'
                    - VideoBucket: !FindInMap [BucketNames, Video, BaseName]
                  - !Sub 
                    - 'arn:aws:s3:::${VideoBucket}-${AWS::Region}-${AWS::AccountId}-${env}/*'
                    - VideoBucket: !FindInMap [BucketNames, Video, BaseName]
                  - !Sub 'arn:aws:s3:::processed-videos-${AWS::Region}-${AWS::AccountId}-${env}'
                  - !Sub 'arn:aws:s3:::processed-videos-${AWS::Region}-${AWS::AccountId}-${env}/*'
        - PolicyName: SSMMessagesAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssmmessages:CreateControlChannel
                  - ssmmessages:CreateDataChannel
                  - ssmmessages:OpenControlChannel
                  - ssmmessages:OpenDataChannel
                Resource: '*'

  InvokeBedrockMarengoRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${StackPrefix}-${env}-invoke-bedrock-marengo-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Policies:
        - PolicyName: CloudWatchLogs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: logs:CreateLogGroup
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${StackPrefix}-${env}-invoke-bedrock-marengo:*'
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:ListBucket
                Resource:
                  - !Sub 
                    - 'arn:aws:s3:::${VideoBucket}-${AWS::Region}-${AWS::AccountId}-${env}/*'
                    - VideoBucket: !FindInMap [BucketNames, Video, BaseName]
                  - !Sub 
                    - 'arn:aws:s3:::${VideoBucket}-${AWS::Region}-${AWS::AccountId}-${env}'
                    - VideoBucket: !FindInMap [BucketNames, Video, BaseName]
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:ListBucket
                Resource: 
                  - !Sub 'arn:aws:s3:::processed-videos-${AWS::Region}-${AWS::AccountId}-${env}/*'
                  - !Sub 'arn:aws:s3:::processed-videos-${AWS::Region}-${AWS::AccountId}-${env}'
        - PolicyName: BedrockAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                  - bedrock:GetAsyncInvoke
                  - bedrock:StartAsyncInvoke
                Resource:
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:async-invoke/*'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/twelvelabs.marengo-embed-2-7-v1:0'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:inference-profile/*'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:model-invocation-job/*'
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                  - bedrock:GetAsyncInvoke
                  - bedrock:StartAsyncInvoke
                Resource:
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:async-invoke/*'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/twelvelabs.marengo-embed-3-0-v1:0'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:inference-profile/*'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:model-invocation-job/*'
              - Effect: Allow
                Action: iam:PassRole
                Resource: !Sub 'arn:aws:iam::${AWS::AccountId}:role/${StackPrefix}-${env}-invoke-bedrock-marengo-role'
                Condition:
                  StringEquals:
                    iam:PassedToService: bedrock.amazonaws.com
              - Effect: Allow
                Action:
                  - aws-marketplace:ViewSubscriptions
                  - aws-marketplace:Subscribe
                Resource: '*'

  InvokeVideoProcessingStepFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${StackPrefix}-${env}-invoke-video-processing-step-function-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Policies:
        - PolicyName: CloudWatchLogs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: logs:CreateLogGroup
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${StackPrefix}-${env}-invoke-video-processing-step-function:*'
        - PolicyName: StepFunctionsAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: states:StartExecution
                Resource: !Sub 'arn:aws:states:${AWS::Region}:${AWS::AccountId}:stateMachine:${StackPrefix}-${env}-pipeline'

  OpenSearchSnapshotRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${StackPrefix}-${env}-opensearch-snapshot-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: es.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Action:
                  - s3:ListBucket
                Effect: Allow
                Resource:
                  - !Sub 
                    - 'arn:aws:s3:::${env}-${FrontendBucket}-${AWS::AccountId}'
                    - FrontendBucket: !FindInMap [BucketNames, Frontend, BaseName]
              - Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                Effect: Allow
                Resource:
                  - !Sub 
                    - 'arn:aws:s3:::${env}-${FrontendBucket}-${AWS::AccountId}/*'
                    - FrontendBucket: !FindInMap [BucketNames, Frontend, BaseName]

  CreateSnapshotLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${StackPrefix}-${env}-create-opensearch-snapshot-lambda-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Policies:
        - PolicyName: CloudWatchLogs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: logs:CreateLogGroup
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${StackPrefix}-${env}-create-opensearch-snapshot:*'
        - PolicyName: OpenSearchAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - es:ESHttpPut
                  - es:ESHttpGet
                Resource: !Sub 'arn:aws:es:${AWS::Region}:${AWS::AccountId}:domain/${StackPrefix}-${env}-aos/*'
              - Effect: Allow
                Action: iam:PassRole
                Resource: !GetAtt OpenSearchSnapshotRole.Arn

  StoreEmbeddingsLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${StackPrefix}-${env}-store-embeddings-opensearch-lambda-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Policies:
        - PolicyName: CloudWatchLogs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: logs:CreateLogGroup
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${StackPrefix}-${env}-store-embeddings-opensearch:*'
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                  - s3:PutObject
                Resource:
                  - !Sub 
                    - 'arn:aws:s3:::${VideoBucket}-${AWS::Region}-${AWS::AccountId}-${env}/*'
                    - VideoBucket: !FindInMap [BucketNames, Video, BaseName]
                  - !Sub 
                    - 'arn:aws:s3:::${VideoBucket}-${AWS::Region}-${AWS::AccountId}-${env}'
                    - VideoBucket: !FindInMap [BucketNames, Video, BaseName]
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                  - s3:ListBucket
                Resource: 
                  - !Sub 'arn:aws:s3:::processed-videos-${AWS::Region}-${AWS::AccountId}-${env}/*'
                  - !Sub 'arn:aws:s3:::processed-videos-${AWS::Region}-${AWS::AccountId}-${env}'
        - PolicyName: EC2NetworkInterface
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:CreateNetworkInterface
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DeleteNetworkInterface
                Resource: '*'
        - PolicyName: OpenSearchAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - es:ESHttpGet
                  - es:ESHttpPost
                  - es:ESHttpPut
                  - es:ESHttpDelete
                  - es:ESHttpHead
                Resource:
                  - !Sub 'arn:aws:es:${AWS::Region}:${AWS::AccountId}:domain/${StackPrefix}-${env}-aos/*'
        - PolicyName: AOSSAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - aoss:APIAccessAll
                Resource:
                  - !Sub 'arn:aws:aoss:${AWS::Region}:${AWS::AccountId}:collection/*'
                  - !Sub 'arn:aws:aoss:${AWS::Region}:${AWS::AccountId}:collection/10hkpuukzb763aqe0uhi'

  StepFunctionsExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${StackPrefix}-${env}-complete-video-processing-pipeline-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: states.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: BedrockAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:GetAsyncInvoke
                Resource:
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:async-invoke/*'
        - PolicyName: IAMPassRole
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: iam:PassRole
                Resource:
                  - !GetAtt ECSTaskExecutionRole.Arn
                  - !GetAtt ECSTaskRole.Arn
        - PolicyName: LambdaInvoke
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource:
                  - !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${StackPrefix}-${env}-invoke-bedrock-marengo'
                  - !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${StackPrefix}-${env}-store-embeddings-opensearch'
        - PolicyName: ECSRunTask
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecs:RunTask
                Resource:
                  - !Ref VideoPreprocessingTaskDefinition
              - Effect: Allow
                Action:
                  - ecs:StopTask
                  - ecs:DescribeTasks
                Resource: '*'
              - Effect: Allow
                Action:
                  - events:PutTargets
                  - events:PutRule
                  - events:DescribeRule
                Resource:
                  - !Sub 'arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/StepFunctionsGetEventsForECSTaskRule'
        - PolicyName: XRayAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                Resource: '*'

  # ============ NEW IAM ROLE FOR FRONTEND CONFIG UPDATE LAMBDA ============
  UpdateFrontendConfigLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${StackPrefix}-${env}-update-frontend-config-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3ConfigAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:PutObjectAcl
                  - s3:GetObject
                Resource:
                  - !Sub 
                    - 'arn:aws:s3:::${env}-${FrontendBucket}-${AWS::AccountId}/*'
                    - FrontendBucket: !FindInMap [BucketNames, Frontend, BaseName]
              - Effect: Allow
                Action:
                  - s3:ListBucket
                Resource:
                  - !Sub 
                    - 'arn:aws:s3:::${env}-${FrontendBucket}-${AWS::AccountId}'
                    - FrontendBucket: !FindInMap [BucketNames, Frontend, BaseName]
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-vpc'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-igw'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref VPC

  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: 10.0.1.0/24
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-public-subnet-1'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [1, !GetAZs '']
      CidrBlock: 10.0.2.0/24
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-public-subnet-2'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  PrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: 10.0.3.0/24
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-private-subnet-1'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  PrivateSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [1, !GetAZs '']
      CidrBlock: 10.0.4.0/24
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-private-subnet-2'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  NatGatewayEIP:
    Type: AWS::EC2::EIP
    DependsOn: InternetGatewayAttachment
    Properties:
      Domain: vpc
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-nat-eip'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  NatGateway:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatGatewayEIP.AllocationId
      SubnetId: !Ref PublicSubnet1
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-nat-gateway'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-public-rt'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  DefaultPublicRoute:
    Type: AWS::EC2::Route
    DependsOn: InternetGatewayAttachment
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet1

  PublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet2

  PrivateRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-private-rt'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  DefaultPrivateRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGateway

  PrivateSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      SubnetId: !Ref PrivateSubnet1

  PrivateSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      SubnetId: !Ref PrivateSubnet2

  ALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub '${StackPrefix}-${env}-alb-sg'
      GroupDescription: !Sub 'Security group for ${StackPrefix}-${env} ALB'
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 8000
          ToPort: 8000
          CidrIp: 0.0.0.0/0
          Description: Allow HTTP 8000 from anywhere
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: Allow HTTPS from anywhere
      SecurityGroupEgress:
        - IpProtocol: "-1"
          CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-alb-sg'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  ECSSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub '${StackPrefix}-${env}-ecs-sg'
      GroupDescription: !Sub 'Security group for ${StackPrefix}-${env} ECS tasks'
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 8000
          ToPort: 8000
          SourceSecurityGroupId: !Ref ALBSecurityGroup
          Description: Allow traffic from ALB
      SecurityGroupEgress:
        - IpProtocol: "-1"
          CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-ecs-sg'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix



  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub '${StackPrefix}-${env}-lambda-sg'
      GroupDescription: !Sub 'Security group for ${StackPrefix}-${env} Lambda functions'
      VpcId: !Ref VPC
      SecurityGroupEgress:
        - IpProtocol: "-1"
          CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-lambda-sg'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  VPCEndpointSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub '${StackPrefix}-${env}-vpc-endpoint-sg'
      GroupDescription: !Sub 'Security group for ${StackPrefix}-${env} VPC endpoints'
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          SourceSecurityGroupId: !Ref ECSSecurityGroup
          Description: Allow HTTPS from ECS tasks
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          SourceSecurityGroupId: !Ref LambdaSecurityGroup
          Description: Allow HTTPS from Lambda functions
      SecurityGroupEgress:
        - IpProtocol: "-1"
          CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-vpc-endpoint-sg'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  S3VPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.s3'
      RouteTableIds:
        - !Ref PrivateRouteTable
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-s3-endpoint'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  ECRAPIVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      VpcEndpointType: Interface
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ecr.api'
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup
      PrivateDnsEnabled: true
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-ecr-api-endpoint'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  ECRDKRVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      VpcEndpointType: Interface
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ecr.dkr'
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup
      PrivateDnsEnabled: true
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-ecr-dkr-endpoint'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  BedrockVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      VpcEndpointType: Interface
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.bedrock'
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup
      PrivateDnsEnabled: true
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-bedrock-endpoint'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  BedrockRuntimeVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      VpcEndpointType: Interface
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.bedrock-runtime'
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup
      PrivateDnsEnabled: true
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-bedrock-runtime-endpoint'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  StepFunctionsVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      VpcEndpointType: Interface
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.states'
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup
      PrivateDnsEnabled: true
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-states-endpoint'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  STSVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      VpcEndpointType: Interface
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.sts'
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup
      PrivateDnsEnabled: true
      Tags:
        - Key: Name
          Value: !Sub '${StackPrefix}-${env}-sts-endpoint'
        - Key: Environment
          Value: !Ref env
        - Key: StackPrefix
          Value: !Ref StackPrefix

  OpenSearchRoleMappingLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${StackPrefix}-${env}-opensearch-role-mapper-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AssumeAdminRole
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: sts:AssumeRole
                Resource: !Sub 'arn:aws:iam::${AWS::AccountId}:role/${StackPrefix}-${env}-opensearch-admin'

  OpenSearchAdminRole:
    Type: AWS::IAM::Role
    DependsOn: OpenSearchRoleMappingLambdaRole
    Properties:
      RoleName: !Sub '${StackPrefix}-${env}-opensearch-admin'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action: sts:AssumeRole
          - Effect: Allow
            Principal:
              AWS: !GetAtt OpenSearchRoleMappingLambdaRole.Arn
            Action: sts:AssumeRole
      Policies:
        - PolicyName: OpenSearchAdminAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - es:ESHttpGet
                  - es:ESHttpPost
                  - es:ESHttpPut
                  - es:ESHttpPatch
                  - es:ESHttpDelete
                  - es:ESHttpHead
                  - es:DescribeDomain
                Resource:
                  - !Sub 'arn:aws:es:${AWS::Region}:${AWS::AccountId}:domain/${StackPrefix}-${env}-aos'
                  - !Sub 'arn:aws:es:${AWS::Region}:${AWS::AccountId}:domain/${StackPrefix}-${env}-aos/*'

  OpenSearchDomain:
    Type: AWS::OpenSearchService::Domain
    Properties:
      DomainName: !Sub '${StackPrefix}-${env}-aos'
      EngineVersion: OpenSearch_3.3
      ClusterConfig:
        InstanceType: r8g.large.search
        InstanceCount: 1
        DedicatedMasterEnabled: false
        ZoneAwarenessEnabled: false
      EBSOptions:
        EBSEnabled: true
        VolumeType: gp3
        VolumeSize: 10
      EncryptionAtRestOptions:
        Enabled: true
      NodeToNodeEncryptionOptions:
        Enabled: true
      DomainEndpointOptions:
        EnforceHTTPS: true
        TLSSecurityPolicy: Policy-Min-TLS-1-2-2019-07
      AdvancedSecurityOptions:
        Enabled: true
        InternalUserDatabaseEnabled: false
        MasterUserOptions:
          MasterUserARN: !GetAtt OpenSearchAdminRole.Arn
      AccessPolicies:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              AWS:
                - !GetAtt ECSTaskRole.Arn
                - !GetAtt SearchSimilarVideosTaskRole.Arn
                - !GetAtt StoreEmbeddingsLambdaRole.Arn
                - !GetAtt CreateSnapshotLambdaRole.Arn
                - !GetAtt OpenSearchAdminRole.Arn
                - !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action:
              - es:ESHttpGet
              - es:ESHttpPost
              - es:ESHttpPut
              - es:ESHttpDelete
              - es:ESHttpHead
            Resource: !Sub 'arn:aws:es:${AWS::Region}:${AWS::AccountId}:domain/${StackPrefix}-${env}-aos/*'

  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Sub '${StackPrefix}-${env}-cluster'
      ClusterSettings:
        - Name: containerInsights
          Value: enabled

  VideoPreprocessingTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Sub '${StackPrefix}-${env}-video-preprocessing-task'
      RequiresCompatibilities:
        - FARGATE
      NetworkMode: awsvpc
      Cpu: '1024'
      Memory: '2048'
      ExecutionRoleArn: !GetAtt ECSTaskExecutionRole.Arn
      TaskRoleArn: !GetAtt ECSTaskRole.Arn
      ContainerDefinitions:
        - Name: !Sub '${StackPrefix}-${env}-video-preprocessor'
          Image: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/video-preprocessing:latest'
          Essential: true
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Sub '/ecs/${StackPrefix}-${env}-video-preprocessing'
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
              awslogs-create-group: 'true'

  SearchSimilarVideosTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    DependsOn:
      - OpenSearchDomain
      - ECRAPIVPCEndpoint
      - ECRDKRVPCEndpoint
      - S3VPCEndpoint
    Properties:
      Family: !Sub '${StackPrefix}-${env}-search-similar-videos-task'
      RequiresCompatibilities:
        - FARGATE
      NetworkMode: awsvpc
      Cpu: '1024'
      Memory: '2048'
      ExecutionRoleArn: !GetAtt ECSTaskExecutionRole.Arn
      TaskRoleArn: !GetAtt SearchSimilarVideosTaskRole.Arn
      RuntimePlatform:
        CpuArchitecture: X86_64
        OperatingSystemFamily: LINUX
      ContainerDefinitions:
        - Name: !Sub '${StackPrefix}-${env}-search-similar-videos-container'
          Image: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/condenast/search-similar-videos:latest'
          Essential: true
          PortMappings:
            - ContainerPort: 8000
              HostPort: 8000
              Protocol: tcp
              AppProtocol: http
          Environment:
            - Name: AWS_REGION
              Value: !Ref AWS::Region
            - Name: OPENSEARCH_CLUSTER_HOST
              Value: !Sub 'https://${OpenSearchDomain.DomainEndpoint}'
            - Name: AWS_S3_BUCKET
              Value: !Sub 
                - '${VideoBucket}-${AWS::Region}-${AWS::AccountId}-${env}'
                - VideoBucket: !FindInMap [BucketNames, Video, BaseName]
            - Name: PORT
              Value: '8000'
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Sub '/ecs/${StackPrefix}-${env}-search-similar-videos-task'
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
              awslogs-create-group: 'true'

  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub '${StackPrefix}-${env}-alb'
      Scheme: internet-facing
      Type: application
      Subnets:
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      SecurityGroups:
        - !Ref ALBSecurityGroup

  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub '${StackPrefix}-${env}-tg'
      Protocol: HTTP
      Port: 8000
      TargetType: ip
      VpcId: !Ref VPC
      HealthCheckPath: /health
      HealthCheckProtocol: HTTP
      HealthCheckIntervalSeconds: 30
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 3

  ALBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 8000
      Protocol: HTTP
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroup

  ECSService:
    Type: AWS::ECS::Service
    DependsOn:
      - ALBListener
      - OpenSearchRoleMappingCustomResource
    Properties:
      ServiceName: !Sub '${StackPrefix}-${env}-service'
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref SearchSimilarVideosTaskDefinition
      DesiredCount: 1
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          Subnets:
            - !Ref PrivateSubnet1
            - !Ref PrivateSubnet2
          SecurityGroups:
            - !Ref ECSSecurityGroup
          AssignPublicIp: DISABLED
      LoadBalancers:
        - ContainerName: !Sub '${StackPrefix}-${env}-search-similar-videos-container'
          ContainerPort: 8000
          TargetGroupArn: !Ref TargetGroup
      HealthCheckGracePeriodSeconds: 60

  AutoScalingTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MaxCapacity: 4
      MinCapacity: 1
      ResourceId: !Sub 'service/${ECSCluster}/${ECSService.Name}'
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
      RoleARN: !Sub 'arn:aws:iam::${AWS::AccountId}:role/aws-service-role/ecs.application-autoscaling.amazonaws.com/AWSServiceRoleForApplicationAutoScaling_ECSService'

  AutoScalingPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: !Sub '${StackPrefix}-${env}-scaling-policy'
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref AutoScalingTarget
      TargetTrackingScalingPolicyConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ALBRequestCountPerTarget
          ResourceLabel: !Sub '${ApplicationLoadBalancer.LoadBalancerFullName}/${TargetGroup.TargetGroupFullName}'
        TargetValue: 1000
        ScaleInCooldown: 300
        ScaleOutCooldown: 60

  InvokeBedrockMarengoFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${StackPrefix}-${env}-invoke-bedrock-marengo'
      Runtime: python3.13
      Handler: index.lambda_handler
      Timeout: 300
      MemorySize: 512
      Role: !GetAtt InvokeBedrockMarengoRole.Arn
      Environment:
        Variables:
          AWS_BUCKET_OWNER: !Ref AWS::AccountId
          OUTPUT_BUCKET: !Sub 'processed-videos-${AWS::Region}-${AWS::AccountId}-${env}'
      VpcConfig:
        SubnetIds:
          - !Ref PrivateSubnet1
          - !Ref PrivateSubnet2
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          bedrock_runtime = boto3.client('bedrock-runtime', region_name=os.environ.get('AWS_DEFAULT_REGION', 'us-east-1'))
          def lambda_handler(event, context):
              bucket = event['bucket']
              key = event['key']
              part = event['part']
              MARENGO_MODEL_VERSION = 3
              print(f"Processing {key} in bucket {bucket}")
              dst_bucket = os.environ['OUTPUT_BUCKET']
              if MARENGO_MODEL_VERSION == 3:
                  modelId = 'twelvelabs.marengo-embed-3-0-v1:0'
                  request_body = {
                      "inputType": "video",
                      "video": {
                          "mediaSource": {
                              "s3Location": {
                                  "uri": f"s3://{bucket}/{key}",
                                  "bucketOwner": os.environ["AWS_BUCKET_OWNER"]
                              }
                          },
                          "embeddingOption": ["visual", "audio", "transcription"],
                          "embeddingScope": ["clip"]
                      }
                  }
              else:
                  modelId = "twelvelabs.marengo-embed-2-7-v1:0"
                  request_body = {
                      "inputType": "video",
                      "mediaSource": {
                          "s3Location": {
                              "uri": f"s3://{bucket}/{key}",
                              "bucketOwner": os.environ["AWS_BUCKET_OWNER"]
                          }
                      },
                      "embeddingOption": ["visual-text", "audio", "visual-image"]
                  }
              if MARENGO_MODEL_VERSION == 3:
                  outputS3uri = f"s3://{dst_bucket}/embeddings-marengo-3/{key}/"
              else:
                  outputS3uri = f"s3://{dst_bucket}/embeddings/{key}/"
              response = bedrock_runtime.start_async_invoke(
                  modelId=modelId,
                  modelInput=request_body,
                  outputDataConfig={"s3OutputDataConfig": {"s3Uri": outputS3uri}}
              )
              print(f"Started Bedrock job: {response['invocationArn']} for part {part}")
              return {
                  'jobId': response['invocationArn'],
                  'invocationArn': response['invocationArn'],
                  'part': part,
                  'outputS3Uri': outputS3uri
              }

  OpenSearchDependenciesLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: !Sub '${StackPrefix}-${env}-opensearch-dependencies'
      CompatibleRuntimes:
        - python3.13
      Content:
        S3Bucket: !Sub 
          - '${env}-${FrontendBucket}-${AWS::AccountId}'
          - FrontendBucket: !FindInMap [BucketNames, Frontend, BaseName]
        S3Key: demo-apps-assets/video-search-demo/lambda-artifacts/opensearch-query-dependencies-2fb22b80-caf2-4d3f-84a6-3f863bf3c409.zip

  FfmpegVideoProcessingDependenciesLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: !Sub '${StackPrefix}-${env}-ffmpeg-video-processing-dependencies'
      CompatibleRuntimes:
        - python3.13
      Content:
        S3Bucket: !Sub 
          - '${env}-${FrontendBucket}-${AWS::AccountId}'
          - FrontendBucket: !FindInMap [BucketNames, Frontend, BaseName]
        S3Key: demo-apps-assets/video-search-demo/lambda-artifacts/ffmpeg-video-processing-dependencies-697fac5e-fb3f-4814-b610-f0d2d3812616.zip

  StoreEmbeddingsFunction:
    Type: AWS::Lambda::Function
    DependsOn:
      - OpenSearchDomain
      - OpenSearchRoleMappingCustomResource
    Properties:
      FunctionName: !Sub '${StackPrefix}-${env}-store-embeddings-opensearch'
      Runtime: python3.13
      Handler: store_embeddings.lambda_handler
      Timeout: 900
      MemorySize: 512
      Role: !GetAtt StoreEmbeddingsLambdaRole.Arn
      Layers:
        - !Ref OpenSearchDependenciesLayer
        - !Ref FfmpegVideoProcessingDependenciesLayer
      Environment:
        Variables:
          OPENSEARCH_CLUSTER_HOST: !Sub 'https://${OpenSearchDomain.DomainEndpoint}'
          THUMBNAIL_BUCKET: !Sub 'processed-videos-${AWS::Region}-${AWS::AccountId}-${env}'
      VpcConfig:
        SubnetIds:
          - !Ref PrivateSubnet1
          - !Ref PrivateSubnet2
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
      Code:
        S3Bucket: !Sub 
          - '${env}-${FrontendBucket}-${AWS::AccountId}'
          - FrontendBucket: !FindInMap [BucketNames, Frontend, BaseName]
        S3Key: 'demo-apps-assets/video-search-demo/lambda-artifacts/store-embeddings-lambda.zip'
      EphemeralStorage:
        Size: 2048

  InvokeStepFunctionFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${StackPrefix}-${env}-invoke-video-processing-step-function'
      Runtime: python3.13
      Handler: index.lambda_handler
      Timeout: 60
      MemorySize: 256
      Role: !GetAtt InvokeVideoProcessingStepFunctionRole.Arn
      Environment:
        Variables:
          STATE_MACHINE_ARN: !Ref VideoProcessingStateMachine
          VIDEO_BUCKET: !Sub 
            - '${VideoBucket}-${AWS::Region}-${AWS::AccountId}-${env}'
            - VideoBucket: !FindInMap [BucketNames, Video, BaseName]
          OUTPUT_BUCKET: !Sub 'processed-videos-${AWS::Region}-${AWS::AccountId}-${env}'
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime
          from urllib.parse import unquote_plus
          sfn_client = boto3.client('stepfunctions')
          STATE_MACHINE_ARN = os.environ['STATE_MACHINE_ARN']
          def lambda_handler(event, context):
              for record in event['Records']:
                  bucket = record['s3']['bucket']['name']
                  key = unquote_plus(record['s3']['object']['key'])
                  dst_bucket = os.environ['OUTPUT_BUCKET']
                  timestamp = str(datetime.now().strftime('%m-%d-%Y_%H-%M-%S'))
                  if not key.lower().endswith(('.mp4', '.mov', '.avi')):
                      print(f"Skipping non-video file: {key}")
                      continue
                  sfn_input = {
                      "detail": {
                          "bucket": {"name": bucket},
                          "object": {"key": key},
                          "dst_bucket": {"key": dst_bucket}
                      }
                  }
                  try:
                      response = sfn_client.start_execution(
                          stateMachineArn=STATE_MACHINE_ARN,
                          name=f"video-process-{key.replace('/', '-').replace('.', '-').replace(' ', '-')[:28]}-{timestamp}",
                          input=json.dumps(sfn_input)
                      )
                      print(f"Started Step Functions execution: {response['executionArn']}")
                  except Exception as e:
                      print(f"Error starting Step Functions: {str(e)}")
                      raise
              return {'statusCode': 200, 'body': json.dumps('Step Functions triggered successfully')}

  # ============ S3 BUCKET IMPORT AND EVENT NOTIFICATION ============
  VideoBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    DependsOn:
      - InvokeStepFunctionPermissionFromS3  #  ADD THIS
    Properties:
      BucketName: !Sub 
        - '${VideoBucket}-${AWS::Region}-${AWS::AccountId}-${env}'
        - VideoBucket: !FindInMap [BucketNames, Video, BaseName]
      CorsConfiguration:
        CorsRules:
          - AllowedOrigins:
              - '*'
            AllowedMethods:
              - GET
              - PUT
              - POST
              - DELETE
              - HEAD
            AllowedHeaders:
              - '*'
            ExposedHeaders:
              - ETag
              - x-amz-request-id
              - x-amz-id-2
            MaxAge: 3600
      NotificationConfiguration:
        LambdaConfigurations:
          - Event: s3:ObjectCreated:*
            Function: !GetAtt InvokeStepFunctionFunction.Arn
            Filter:
              S3Key:
                Rules:
                  - Name: suffix
                    Value: .mp4

  # ============ OUTPUT VIDEO BUCKET (for processed videos and thumbnails) ============
  OutputVideoBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    Properties:
      BucketName: !Sub 'processed-videos-${AWS::Region}-${AWS::AccountId}-${env}'
      CorsConfiguration:
        CorsRules:
          - AllowedOrigins:
              - '*'
            AllowedMethods:
              - GET
              - PUT
              - POST
              - DELETE
              - HEAD
            AllowedHeaders:
              - '*'
            ExposedHeaders:
              - ETag
              - x-amz-request-id
              - x-amz-id-2
            MaxAge: 3600

  # ============ S3 BUCKET POLICY FOR BEDROCK ACCESS ============
  OutputVideoBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref OutputVideoBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowBedrockBucketLevelAccess
            Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action:
              - s3:GetBucketLocation
              - s3:ListBucket
            Resource: !Sub 'arn:aws:s3:::processed-videos-${AWS::Region}-${AWS::AccountId}-${env}'
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
          
          - Sid: AllowBedrockObjectLevelAccess
            Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action:
              - s3:GetObject      # Bedrock reads the input video
              - s3:PutObject      # Bedrock writes embeddings
            Resource: !Sub 'arn:aws:s3:::processed-videos-${AWS::Region}-${AWS::AccountId}-${env}/*'  #  ADD /*
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId

  # ============ S3 BUCKET AUTO-DELETION RESOURCES ============
  EmptyBucketLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${StackPrefix}-${env}-empty-bucket-lambda-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3BucketEmptyAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:ListBucket
                  - s3:ListBucketVersions
                Resource: 
                  - !Sub 
                    - 'arn:aws:s3:::${VideoBucket}-${AWS::Region}-${AWS::AccountId}-${env}'
                    - VideoBucket: !FindInMap [BucketNames, Video, BaseName]
                  - !Sub 'arn:aws:s3:::processed-videos-${AWS::Region}-${AWS::AccountId}-${env}'
              - Effect: Allow
                Action:
                  - s3:DeleteObject
                  - s3:DeleteObjectVersion
                Resource: 
                  - !Sub 
                    - 'arn:aws:s3:::${VideoBucket}-${AWS::Region}-${AWS::AccountId}-${env}/*'
                    - VideoBucket: !FindInMap [BucketNames, Video, BaseName]
                  - !Sub 'arn:aws:s3:::processed-videos-${AWS::Region}-${AWS::AccountId}-${env}/*'

  EmptyBucketFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${StackPrefix}-${env}-empty-bucket'
      Runtime: python3.13
      Handler: index.lambda_handler
      Timeout: 900
      MemorySize: 256
      Role: !GetAtt EmptyBucketLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          import logging
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          s3 = boto3.client('s3')
          
          def lambda_handler(event, context):
              """Empty S3 bucket on CloudFormation Delete event"""
              logger.info(f"Event: {json.dumps(event)}")
              
              try:
                  bucket_name = event['ResourceProperties']['BucketName']
                  request_type = event['RequestType']
                  
                  if request_type == 'Delete':
                      logger.info(f"Emptying bucket: {bucket_name}")
                      empty_bucket(bucket_name)
                      logger.info(f"Successfully emptied bucket: {bucket_name}")
                  else:
                      logger.info(f"Request type {request_type} - no action needed")
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                  
              except Exception as e:
                  logger.error(f"Error: {str(e)}")
                  import traceback
                  traceback.print_exc()
                  cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)})
          
          def empty_bucket(bucket_name):
              """Delete all objects and versions from the bucket"""
              try:
                  # Delete all object versions and delete markers
                  paginator = s3.get_paginator('list_object_versions')
                  page_iterator = paginator.paginate(Bucket=bucket_name)
                  
                  for page in page_iterator:
                      objects_to_delete = []
                      
                      # Add all versions
                      if 'Versions' in page:
                          for version in page['Versions']:
                              objects_to_delete.append({
                                  'Key': version['Key'],
                                  'VersionId': version['VersionId']
                              })
                      
                      # Add all delete markers
                      if 'DeleteMarkers' in page:
                          for delete_marker in page['DeleteMarkers']:
                              objects_to_delete.append({
                                  'Key': delete_marker['Key'],
                                  'VersionId': delete_marker['VersionId']
                              })
                      
                      # Delete objects in batches
                      if objects_to_delete:
                          logger.info(f"Deleting {len(objects_to_delete)} objects/versions")
                          s3.delete_objects(
                              Bucket=bucket_name,
                              Delete={'Objects': objects_to_delete}
                          )
                  
                  # Also delete any remaining objects (for non-versioned buckets)
                  paginator = s3.get_paginator('list_objects_v2')
                  page_iterator = paginator.paginate(Bucket=bucket_name)
                  
                  for page in page_iterator:
                      if 'Contents' in page:
                          objects_to_delete = [{'Key': obj['Key']} for obj in page['Contents']]
                          if objects_to_delete:
                              logger.info(f"Deleting {len(objects_to_delete)} remaining objects")
                              s3.delete_objects(
                                  Bucket=bucket_name,
                                  Delete={'Objects': objects_to_delete}
                              )
                  
                  logger.info(f"Bucket {bucket_name} emptied successfully")
                  
              except Exception as e:
                  logger.error(f"Error emptying bucket {bucket_name}: {str(e)}")
                  raise

  EmptyBucketOnDelete:
    Type: Custom::EmptyBucket
    Properties:
      ServiceToken: !GetAtt EmptyBucketFunction.Arn
      BucketName: !Ref VideoBucket

  EmptyOutputBucketOnDelete:
    Type: Custom::EmptyBucket
    Properties:
      ServiceToken: !GetAtt EmptyBucketFunction.Arn
      BucketName: !Ref OutputVideoBucket

  InvokeStepFunctionPermissionFromS3:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt InvokeStepFunctionFunction.Arn
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceArn: !Sub 
        - 'arn:aws:s3:::${VideoBucket}-${AWS::Region}-${AWS::AccountId}-${env}'
        - VideoBucket: !FindInMap [BucketNames, Video, BaseName]
      SourceAccount: !Ref AWS::AccountId

  CreateSnapshotFunction:
    Type: AWS::Lambda::Function
    DependsOn:
      - OpenSearchDomain
      - OpenSearchRoleMappingCustomResource
    Properties:
      FunctionName: !Sub '${StackPrefix}-${env}-create-opensearch-snapshot'
      Runtime: python3.12
      Handler: index.lambda_handler
      Timeout: 300
      MemorySize: 512
      Role: !GetAtt CreateSnapshotLambdaRole.Arn
      Environment:
        Variables:
          OPENSEARCH_CLUSTER_HOST: !Sub 'https://${OpenSearchDomain.DomainEndpoint}'
          SNAPSHOT_ROLE_ARN: !GetAtt OpenSearchSnapshotRole.Arn
          S3_BUCKET: !Sub 
            - '${env}-${FrontendBucket}-${AWS::AccountId}'
            - FrontendBucket: !FindInMap [BucketNames, Frontend, BaseName]
          REPO_NAME: !Sub '${StackPrefix}-${env}-snapshot-repo'
          
      Layers:
        - !Sub 'arn:aws:lambda:${AWS::Region}:770693421928:layer:Klayers-p312-requests:18'

      VpcConfig:
        SubnetIds:
          - !Ref PrivateSubnet1
          - !Ref PrivateSubnet2
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
      Code:
        ZipFile: |
          import boto3
          import requests
          import time
          import json
          import os
          import logging
          from botocore.awsrequest import AWSRequest
          from botocore.auth import SigV4Auth
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          def signed_request(method, url, region, service, credentials, json_body=None, headers=None, timeout=60):
              body = None
              if json_body is not None:
                  body = json.dumps(json_body)
                  if headers is None:
                      headers = {}
                  headers = dict(headers)
                  headers.setdefault("Content-Type", "application/json")
              aws_request = AWSRequest(method=method.upper(), url=url, data=body, headers=headers or {})
              SigV4Auth(credentials, service, region).add_auth(aws_request)
              prepared = requests.Request(method=aws_request.method, url=aws_request.url, data=aws_request.body, headers=dict(aws_request.headers)).prepare()
              session = requests.Session()
              response = session.send(prepared, timeout=timeout)
              return response
          def lambda_handler(event, context):
              try:
                  region = os.environ.get('AWS_DEFAULT_REGION', 'us-east-1')
                  service = "es"
                  function = event.get("function", "register-snapshot-repo")
                  domain = os.getenv("OPENSEARCH_CLUSTER_HOST", "").replace("https://", "").replace("http://", "")
                  repo_name = os.getenv("REPO_NAME", "condenast-snapshot-repo")
                  bucket = os.getenv("S3_BUCKET", "aihouse-dist")
                  role_arn = os.getenv("SNAPSHOT_ROLE_ARN")
                  snapshot_name = f"manual-snapshot-{int(time.time())}"
                  if not domain:
                      raise ValueError("OPENSEARCH_CLUSTER_HOST environment variable not set")
                  if not role_arn:
                      raise ValueError("SNAPSHOT_ROLE_ARN environment variable not set")
                  logger.info(f"Config: domain={domain}, repo={repo_name}, bucket={bucket}")
                  session = boto3.Session()
                  credentials = session.get_credentials().get_frozen_credentials()
                  headers = {"Content-Type": "application/json"}
                  register_payload = {"type": "s3", "settings": {"bucket": bucket, "region": region, "role_arn": role_arn, "base_path": "opensearch-snapshots", "server_side_encryption": True}}
                  url_repo = f"https://{domain}/_snapshot/{repo_name}"
                  logger.info(f"Registering repo {repo_name} ...")
                  r = signed_request("PUT", url_repo, region, service, credentials, json_body=register_payload, headers=headers)
                  logger.info(f"Register repo response: {r.status_code} {r.text}")
                  if r.status_code not in (200, 201):
                      logger.error(f"Repo registration failed: {r.text}")
                      return {"statusCode": 400, "body": json.dumps({"error": "Repo registration failed", "details": r.text, "status_code": r.status_code})}
                  if function == "register-snapshot-repo":
                      return {"statusCode": 200, "body": json.dumps({"message": "Repository registered successfully", "repo_name": repo_name})}
                  url_snap = f"https://{domain}/_snapshot/{repo_name}/{snapshot_name}"
                  logger.info(f"Creating snapshot {snapshot_name} ...")
                  r = signed_request("PUT", url_snap, region, service, credentials, headers=headers)
                  logger.info(f"Create snapshot response: {r.status_code} {r.text}")
                  if r.status_code not in (200, 201):
                      logger.error(f"Snapshot creation failed: {r.text}")
                      return {"statusCode": 400, "body": json.dumps({"error": "Snapshot creation failed", "details": r.text, "status_code": r.status_code})}
                  time.sleep(10)
                  url_status = f"https://{domain}/_snapshot/{repo_name}/{snapshot_name}/_status"
                  r = signed_request("GET", url_status, region, service, credentials)
                  logger.info(f"Snapshot status: {r.status_code} {r.text}")
                  status_data = r.json() if r.status_code == 200 else {}
                  return {"statusCode": 200, "body": json.dumps({"message": "Snapshot created successfully", "snapshot_name": snapshot_name, "repo_name": repo_name, "status": status_data})}
              except Exception as e:
                  logger.error(f"Error: {str(e)}", exc_info=True)
                  return {"statusCode": 500, "body": json.dumps({"error": "Internal server error", "message": str(e)})}

  OpenSearchRoleMappingLambda:
    Type: AWS::Lambda::Function
    DependsOn: OpenSearchDomain
    Properties:
      FunctionName: !Sub '${StackPrefix}-${env}-opensearch-role-mapper'
      Runtime: python3.11
      Handler: index.lambda_handler
      Timeout: 60
      MemorySize: 256
      Role: !GetAtt OpenSearchRoleMappingLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import urllib3
          import os
          from botocore.auth import SigV4Auth
          from botocore.awsrequest import AWSRequest
          
          http = urllib3.PoolManager()
          sts = boto3.client('sts')
          
          def send_response(event, context, status, data=None):
              """Send response to CloudFormation"""
              response_body = {
                  'Status': status,
                  'PhysicalResourceId': event.get('PhysicalResourceId', 'OpenSearchRoleMapping'),
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': data or {}
              }
              
              try:
                  http.request(
                      'PUT',
                      event['ResponseURL'],
                      body=json.dumps(response_body),
                      headers={'Content-Type': 'application/json'}
                  )
              except Exception as e:
                  print(f"Failed to send response: {str(e)}")
          
          def lambda_handler(event, context):
              """Maps IAM roles to OpenSearch internal roles"""
              print(f"Event: {json.dumps(event)}")
              
              try:
                  # Handle CloudFormation Delete
                  if event['RequestType'] == 'Delete':
                      print("Delete request - no action needed")
                      send_response(event, context, 'SUCCESS')
                      return
                  
                  # Get parameters from custom resource properties
                  domain_endpoint = event['ResourceProperties']['DomainEndpoint'].replace('https://', '').replace('http://', '')
                  admin_role_arn = event['ResourceProperties']['AdminRoleArn']
                  role_mappings = event['ResourceProperties']['RoleMappings']
                  
                  print(f"Domain: {domain_endpoint}")
                  print(f"Admin Role: {admin_role_arn}")
                  print(f"Mappings: {json.dumps(role_mappings, indent=2)}")
                  
                  # Assume the admin role
                  print(" Assuming OpenSearch Admin Role...")
                  assumed_role = sts.assume_role(
                      RoleArn=admin_role_arn,
                      RoleSessionName='cfn-opensearch-mapper',
                      DurationSeconds=900
                  )
                  
                  admin_creds = assumed_role['Credentials']
                  print(" Admin role assumed successfully")
                  
                  # Create credentials object for SigV4Auth
                  class TempCredentials:
                      def __init__(self, access_key, secret_key, token):
                          self.access_key = access_key
                          self.secret_key = secret_key
                          self.token = token
                  
                  credentials = TempCredentials(
                      admin_creds['AccessKeyId'],
                      admin_creds['SecretAccessKey'],
                      admin_creds['SessionToken']
                  )
                  
                  region = os.environ.get('AWS_DEFAULT_REGION', 'us-east-1')
                  service = 'es'
                  results = {}
                  
                  # Map each role
                  for opensearch_role, backend_roles in role_mappings.items():
                      url = f"https://{domain_endpoint}/_plugins/_security/api/rolesmapping/{opensearch_role}"
                      
                      # Get existing mapping first
                      get_request = AWSRequest(
                          method='GET',
                          url=url,
                          headers={'Content-Type': 'application/json'}
                      )
                      SigV4Auth(credentials, service, region).add_auth(get_request)
                      
                      get_response = http.request(
                          method=get_request.method,
                          url=get_request.url,
                          headers=dict(get_request.headers)
                      )
                      
                      existing_mapping = {}
                      if get_response.status == 200:
                          response_json = json.loads(get_response.data.decode('utf-8'))
                          existing_mapping = response_json.get(opensearch_role, {})
                      
                      # Build complete mapping
                      body = {
                          "backend_roles": backend_roles,
                          "hosts": existing_mapping.get("hosts", []),
                          "users": existing_mapping.get("users", [])
                      }
                      
                      print(f" Mapping {opensearch_role} with {len(backend_roles)} roles")
                      
                      # PUT to update mapping
                      request = AWSRequest(
                          method='PUT',
                          url=url,
                          data=json.dumps(body),
                          headers={'Content-Type': 'application/json'}
                      )
                      SigV4Auth(credentials, service, region).add_auth(request)
                      
                      response = http.request(
                          method=request.method,
                          url=request.url,
                          body=request.body,
                          headers=dict(request.headers)
                      )
                      
                      response_data = response.data.decode('utf-8')
                      print(f"Response: {response.status} - {response_data}")
                      
                      if response.status in [200, 201]:
                          results[opensearch_role] = 'SUCCESS'
                      else:
                          results[opensearch_role] = f'FAILED: {response_data}'
                  
                  # Check for failures
                  failures = [role for role, result in results.items() if 'FAILED' in result]
                  
                  if failures:
                      print(f" Failed to map: {failures}")
                      send_response(event, context, 'FAILED', {'Results': results})
                  else:
                      print(f" All mappings successful")
                      send_response(event, context, 'SUCCESS', {'Results': results})
              
              except Exception as e:
                  print(f" Error: {str(e)}")
                  import traceback
                  traceback.print_exc()
                  send_response(event, context, 'FAILED', {'Error': str(e)})

  # ============ CLOUDFRONT RESOURCES ============
  FrontendOAC:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub '${StackPrefix}-${env}-frontend-oac'
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  FrontendDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        DefaultRootObject: index.html
        HttpVersion: http2
        IPV6Enabled: true
        DefaultCacheBehavior:
          TargetOriginId: FrontendS3Origin
          ViewerProtocolPolicy: redirect-to-https
          CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6 # AWS "CachingOptimized"
        Origins:
          - Id: FrontendS3Origin
            DomainName: !Sub 
              - '${env}-${FrontendBucket}-${AWS::AccountId}.s3.${AWS::Region}.${AWS::URLSuffix}'
              - FrontendBucket: !FindInMap [BucketNames, Frontend, BaseName]
            OriginAccessControlId: !GetAtt FrontendOAC.Id
            OriginPath: '/demo-apps-assets/video-search-demo/FE'
            S3OriginConfig:
              OriginAccessIdentity: ""

  # Lambda Role for managing bucket policy
  ManageBucketPolicyLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${StackPrefix}-${env}-manage-bucket-policy-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3BucketPolicyAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutBucketPolicy
                  - s3:GetBucketPolicy
                  - s3:DeleteBucketPolicy
                Resource: !Sub 
                  - 'arn:aws:s3:::${env}-${FrontendBucket}-${AWS::AccountId}'
                  - FrontendBucket: !FindInMap [BucketNames, Frontend, BaseName]

  # Lambda Function for managing bucket policy
  ManageBucketPolicyFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${StackPrefix}-${env}-manage-bucket-policy'
      Runtime: python3.13
      Handler: index.handler
      Role: !GetAtt ManageBucketPolicyLambdaRole.Arn
      Timeout: 60
      Code:
        ZipFile: |
          import json
          import boto3
          import urllib3
          
          s3 = boto3.client('s3')
          http = urllib3.PoolManager()
          
          def handler(event, context):
              print(f"Event: {json.dumps(event)}")
              
              response_data = {}
              status = 'SUCCESS'
              reason = ''
              physical_id = event.get('PhysicalResourceId', 'ManageBucketPolicy')
              
              try:
                  bucket_name = event['ResourceProperties']['BucketName']
                  policy_json = event['ResourceProperties']['PolicyDocument']
                  
                  if event['RequestType'] in ['Create', 'Update']:
                      s3.put_bucket_policy(
                          Bucket=bucket_name,
                          Policy=json.dumps(policy_json)
                      )
                      reason = f"Successfully applied policy to bucket {bucket_name}"
                      print(reason)
                  elif event['RequestType'] == 'Delete':
                      try:
                          s3.delete_bucket_policy(Bucket=bucket_name)
                          reason = f"Successfully removed policy from bucket {bucket_name}"
                      except s3.exceptions.NoSuchBucketPolicy:
                          reason = "No policy to delete"
                      print(reason)
              except Exception as e:
                  status = 'FAILED'
                  reason = f"Error: {str(e)}"
                  print(reason)
              
              response_body = {
                  'Status': status,
                  'Reason': reason,
                  'PhysicalResourceId': physical_id,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': response_data
              }
              
              json_response = json.dumps(response_body).encode('utf-8')
              
              try:
                  http.request(
                      'PUT',
                      event['ResponseURL'],
                      body=json_response,
                      headers={'Content-Type': 'application/json'}
                  )
              except Exception as e:
                  print(f"Failed to send response: {e}")
                  raise
              
              return response_data

  # Custom Resource (replaces the deleted FrontendBucketPolicy)
  FrontendBucketPolicyCustomResource:
    Type: Custom::S3BucketPolicy
    Properties:
      ServiceToken: !GetAtt ManageBucketPolicyFunction.Arn
      BucketName: !Sub 
        - '${env}-${FrontendBucket}-${AWS::AccountId}'
        - FrontendBucket: !FindInMap [BucketNames, Frontend, BaseName]
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: !Sub '${env}-${StackPrefix}-AllowCloudFrontServicePrincipalReadOnly'
            Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub 
              - 'arn:aws:s3:::${env}-${FrontendBucket}-${AWS::AccountId}/demo-apps-assets/video-search-demo/FE/*'
              - FrontendBucket: !FindInMap [BucketNames, Frontend, BaseName]
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub 'arn:aws:cloudfront::${AWS::AccountId}:distribution/${FrontendDistribution}'

  ApiDistribution:
    Type: AWS::CloudFront::Distribution
    DependsOn: ApplicationLoadBalancer
    Properties:
      DistributionConfig:
        Enabled: true
        HttpVersion: http2
        IPV6Enabled: true
        DefaultCacheBehavior:
          TargetOriginId: ApiOrigin
          ViewerProtocolPolicy: https-only
          AllowedMethods: [GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE]
          CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad
          OriginRequestPolicyId: 216adef6-5c7f-47e4-b989-5492eafa07d3
        Origins:
          - Id: ApiOrigin
            DomainName: !GetAtt ApplicationLoadBalancer.DNSName
            CustomOriginConfig:
              OriginProtocolPolicy: http-only
              HTTPPort: 8000
              HTTPSPort: 443

  # ============ NEW LAMBDA FUNCTION FOR FRONTEND CONFIG UPDATE ============
  UpdateFrontendConfigLambda:
    Type: AWS::Lambda::Function
    DependsOn:
      - ApplicationLoadBalancer
      - ECSService
    Properties:
      FunctionName: !Sub '${StackPrefix}-${env}-update-frontend-config'
      Runtime: python3.11
      Handler: index.lambda_handler
      Timeout: 60
      MemorySize: 256
      Role: !GetAtt UpdateFrontendConfigLambdaRole.Arn
      Environment:
        Variables:
          FRONTEND_S3_BUCKET: !Sub 
            - '${env}-${FrontendBucket}-${AWS::AccountId}'
            - FrontendBucket: !FindInMap [BucketNames, Frontend, BaseName]
      Code:
        ZipFile: |
          import json
          import boto3
          import urllib3
          from datetime import datetime
          import os
          
          http = urllib3.PoolManager()
          s3 = boto3.client('s3')
          
          def send_response(event, context, status, data=None):
              """Send response to CloudFormation"""
              response_body = {
                  'Status': status,
                  'PhysicalResourceId': event.get('PhysicalResourceId', 'UpdateFrontendConfig'),
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': data or {}
              }
              
              try:
                  http.request(
                      'PUT',
                      event['ResponseURL'],
                      body=json.dumps(response_body),
                      headers={'Content-Type': 'application/json'}
                  )
              except Exception as e:
                  print(f"Failed to send response: {str(e)}")
          
          def lambda_handler(event, context):
              """Update frontend config.json and call demo completion API"""
              print(f"Event: {json.dumps(event)}")
              
              # Initialize result data with defaults
              result_data = {
                  'BackendUrl': None,
                  'ConfigUploaded': None
              }
              
              try:
                  if event['RequestType'] == 'Delete':
                      print("Delete request - no action needed")
                      send_response(event, context, 'SUCCESS')
                      return
                  
                  # Get values from custom resource properties
                  resource_properties = event.get('ResourceProperties', {})
                  api_base_url = resource_properties.get('ApiBaseUrl')
                  
                  if not api_base_url:
                      error_msg = "ApiBaseUrl not provided in custom resource properties"
                      print(f" Critical Error: {error_msg}")
                      send_response(event, context, 'FAILED', {'Error': error_msg})
                      return
                  
                  s3_bucket = os.environ.get('FRONTEND_S3_BUCKET')
                  
                  backend_url = api_base_url.rstrip("/")
                  result_data['BackendUrl'] = backend_url
                  
                  print(f" Backend URL (API CloudFront): {backend_url}")
                  
                  # Create config.json
                  config = {
                      "backendUrl": backend_url,
                      "apiVersion": "v1",
                      "environment": "production",
                      "features": {
                          "marengo3Enabled": True,
                          "uploadEnabled": True,
                          "maxUploadSizeMB": 5
                      },
                      "endpoints": {
                          "search": "/search",
                          "search3": "/search-3",
                          "list": "/list",
                          "upload": "/generate-upload-presigned-url",
                          "health": "/health"
                      },
                      "metadata": {
                          "lastUpdated": datetime.utcnow().isoformat() + "Z",
                          "version": "1.0.0",
                          "source": "cloudformation-lambda"
                      }
                  }
                  
                  print(f" Config created: {json.dumps(config, indent=2)}")
                  
                  # Upload to S3 with error handling
                  if s3_bucket:
                      try:
                          print(f" Uploading config.json to s3://{s3_bucket}/demo-apps-assets/video-search-demo/FE/config.json")
                          s3.put_object(
                              Bucket=s3_bucket,
                              Key='demo-apps-assets/video-search-demo/FE/config.json',
                              Body=json.dumps(config, indent=2),
                              ContentType='application/json',
                              ContentDisposition='inline',
                              CacheControl='no-cache, no-store, must-revalidate',
                              Metadata={
                                  'updated-by': 'cloudformation',
                                  'backend-url': backend_url
                              }
                          )
                          
                          print(" config.json uploaded successfully")
                          result_data['ConfigUploaded'] = f's3://{s3_bucket}/demo-apps-assets/video-search-demo/FE/config.json'
                          result_data['S3UploadSuccess'] = True
                          
                      except Exception as s3_error:
                          error_msg = f"S3 upload failed: {str(s3_error)}"
                          print(f" {error_msg}")
                          # Continue execution - don't fail the stack for S3 errors
                  else:
                      error_msg = "FRONTEND_S3_BUCKET environment variable not set"
                      print(f" Warning: {error_msg}")
                  
                  # Send SUCCESS response to CloudFormation
                  print(f" Final result: {json.dumps(result_data, indent=2)}")
                  send_response(event, context, 'SUCCESS', result_data)
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps(result_data)
                  }
                  
              except Exception as e:
                  error_msg = f"Critical error in lambda execution: {str(e)}"
                  print(f" {error_msg}")
                  import traceback
                  traceback.print_exc()
                  
                  send_response(event, context, 'FAILED', {'Error': error_msg})
                  
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'Error': error_msg})
                  }

  OpenSearchRoleMappingCustomResource:
    Type: Custom::OpenSearchRoleMapping
    DependsOn:
      - OpenSearchDomain
      - OpenSearchRoleMappingLambda
      - StoreEmbeddingsLambdaRole
      - CreateSnapshotLambdaRole
      - SearchSimilarVideosTaskRole
    Properties:
      ServiceToken: !GetAtt OpenSearchRoleMappingLambda.Arn
      DomainEndpoint: !GetAtt OpenSearchDomain.DomainEndpoint
      AdminRoleArn: !GetAtt OpenSearchAdminRole.Arn
      RoleMappings:
        all_access:
          - !GetAtt StoreEmbeddingsLambdaRole.Arn
          - !GetAtt CreateSnapshotLambdaRole.Arn
          - !GetAtt SearchSimilarVideosTaskRole.Arn
          - !GetAtt ECSTaskRole.Arn
          - !Sub 'arn:aws:iam::${AWS::AccountId}:root'

  # ============ NEW CUSTOM RESOURCE FOR FRONTEND CONFIG UPDATE ============
  UpdateFrontendConfigCustomResource:
    Type: Custom::UpdateFrontendConfig
    DependsOn:
      - ECSService
      - ApplicationLoadBalancer
      - UpdateFrontendConfigLambda
      - ApiDistribution
    Properties:
      ServiceToken: !GetAtt UpdateFrontendConfigLambda.Arn
      FrontendBucket: !Sub 
        - '${env}-${FrontendBucket}-${AWS::AccountId}'
        - FrontendBucket: !FindInMap [BucketNames, Frontend, BaseName]
      ApiBaseUrl: !Sub 'https://${ApiDistribution.DomainName}'
      Trigger: !Sub '${AWS::StackName}-${ApplicationLoadBalancer}'

  InvokeBedrockMarengoInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref InvokeBedrockMarengoFunction
      Action: lambda:InvokeFunction
      Principal: states.amazonaws.com

  StoreEmbeddingsInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref StoreEmbeddingsFunction
      Action: lambda:InvokeFunction
      Principal: states.amazonaws.com

  VideoProcessingStateMachine:
    Type: AWS::StepFunctions::StateMachine
    DependsOn:
      - InvokeBedrockMarengoFunction
      - StoreEmbeddingsFunction
    Properties:
      StateMachineName: !Sub '${StackPrefix}-${env}-pipeline'
      RoleArn: !GetAtt StepFunctionsExecutionRole.Arn
      DefinitionString: !Sub |
        {
          "Comment": "Video preprocessing pipeline with Bedrock Marengo and OpenSearch",
          "StartAt": "PreprocessVideo",
          "States": {
            "PreprocessVideo": {
              "Type": "Task",
              "Resource": "arn:aws:states:::ecs:runTask.waitForTaskToken",
              "Parameters": {
                "LaunchType": "FARGATE",
                "Cluster": "${ECSCluster.Arn}",
                "TaskDefinition": "${VideoPreprocessingTaskDefinition}",
                "NetworkConfiguration": {
                  "AwsvpcConfiguration": {
                    "Subnets": ["${PrivateSubnet1}", "${PrivateSubnet2}"],
                    "SecurityGroups": ["${ECSSecurityGroup}"],
                    "AssignPublicIp": "DISABLED"
                  }
                },
                "Overrides": {
                  "ContainerOverrides": [
                    {
                      "Name": "${StackPrefix}-${env}-video-preprocessor",
                      "Environment": [
                        {"Name": "BUCKET_NAME", "Value.$": "$.detail.bucket.name"},
                        {"Name": "VIDEO_KEY", "Value.$": "$.detail.object.key"},
                        {"Name": "DESTINATION_BUCKET", "Value.$": "$.detail.dst_bucket.key"},
                        {"Name": "TASK_TOKEN", "Value.$": "$$.Task.Token"}
                      ]
                    }
                  ]
                }
              },
              "ResultPath": "$.preprocessingResult",
              "Next": "ProcessVideoParts",
              "Retry": [
                {
                  "ErrorEquals": ["States.TaskFailed"],
                  "IntervalSeconds": 30,
                  "MaxAttempts": 1,
                  "BackoffRate": 2
                }
              ],
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "ResultPath": "$.error",
                  "Next": "HandleFailure"
                }
              ]
            },
            "ProcessVideoParts": {
              "Type": "Map",
              "ItemsPath": "$.preprocessingResult.parts",
              "MaxConcurrency": 5,
              "Iterator": {
                "StartAt": "StartBedrockMarengo",
                "States": {
                  "StartBedrockMarengo": {
                    "Type": "Task",
                    "Resource": "${InvokeBedrockMarengoFunction.Arn}",
                    "Parameters": {
                      "bucket.$": "$.bucket",
                      "key.$": "$.key",
                      "part.$": "$.part"
                    },
                    "ResultPath": "$.modelJob",
                    "Next": "WaitBeforePoll"
                  },
                  "WaitBeforePoll": {
                    "Type": "Wait",
                    "Seconds": 10,
                    "Next": "GetAsyncInvoke"
                  },
                  "GetAsyncInvoke": {
                    "Type": "Task",
                    "Parameters": {
                      "InvocationArn.$": "$.modelJob.invocationArn"
                    },
                    "Resource": "arn:aws:states:::aws-sdk:bedrockruntime:getAsyncInvoke",
                    "Next": "IsModelDone",
                    "ResultPath": "$.status"
                  },
                  "IsModelDone": {
                    "Type": "Choice",
                    "Choices": [
                      {
                        "Variable": "$.status.Status",
                        "StringEquals": "Completed",
                        "Next": "StoreEmbeddings"
                      },
                      {
                        "Variable": "$.status.Status",
                        "StringEquals": "Failed",
                        "Next": "PartFailed"
                      },
                      {
                        "Variable": "$.status.Status",
                        "StringEquals": "Stopped",
                        "Next": "PartFailed"
                      }
                    ],
                    "Default": "WaitBeforePoll"
                  },
                  "StoreEmbeddings": {
                    "Type": "Task",
                    "Resource": "${StoreEmbeddingsFunction.Arn}",
                    "Parameters": {
                      "outputS3Path.$": "$.status.OutputDataConfig.S3OutputDataConfig.S3Uri",
                      "part.$": "$.part",
                      "originalVideo": {
                        "bucket.$": "$.bucket",
                        "key.$": "$.key"
                      }
                    },
                    "End": true
                  },
                  "PartFailed": {
                    "Type": "Fail",
                    "Cause": "Bedrock processing failed for video part"
                  }
                }
              },
              "ResultPath": "$.processingResults",
              "Next": "AllPartsComplete",
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "ResultPath": "$.mapError",
                  "Next": "HandleFailure"
                }
              ]
            },
            "AllPartsComplete": {
              "Type": "Succeed",
              "Comment": "All video parts processed and stored in OpenSearch"
            },
            "HandleFailure": {
              "Type": "Fail",
              "Error": "VideoProcessingFailed",
              "Cause": "Pipeline failed - check logs for details"
            }
          }
        }
        
Outputs:
  CloudFrontURL:
    Description: CloudFront URL for the frontend
    Value: !GetAtt FrontendDistribution.DomainName
    Export:
      Name: !Sub '${AWS::StackName}-FrontendCloudFrontDomainName'
