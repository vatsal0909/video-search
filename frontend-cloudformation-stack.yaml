AWSTemplateFormatVersion: '2010-09-09'
Description: |
  Frontend Infrastructure for Video Search Application
  Creates S3 bucket and CloudFront distribution for static website hosting

Parameters:
  Environment:
    Type: String
    Default: 'dev'
    AllowedValues: ['dev', 'demo', 'stage', 'prod']
    Description: 'Environment name for resource naming'
  
  ProjectName:
    Type: String
    Default: 'video-search'
    Description: 'Project name for resource naming'
    AllowedPattern: '[a-zA-Z0-9-]+'
    MaxLength: 20

Resources:
  # S3 Bucket for hosting static website
  FrontendBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    Properties:
      BucketName: !Sub '${ProjectName}-frontend-${Environment}-${AWS::AccountId}'
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: index.html
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders: ['*']
            AllowedMethods: [GET, HEAD]
            AllowedOrigins: ['*']
            MaxAge: 3600
      Tags:
        - Key: Project
          Value: !Sub '${ProjectName}'
        - Key: Environment
          Value: !Ref Environment
        - Key: Purpose
          Value: 'Frontend Static Website'

  # Custom resource to automatically empty S3 bucket before deletion
  EmptyBucketLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-${Environment}-empty-bucket-lambda-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3BucketEmptyAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:ListBucket
                  - s3:ListBucketVersions
                Resource: !Sub 'arn:aws:s3:::${ProjectName}-frontend-${Environment}-${AWS::AccountId}'
              - Effect: Allow
                Action:
                  - s3:DeleteObject
                  - s3:DeleteObjectVersion
                Resource: !Sub 'arn:aws:s3:::${ProjectName}-frontend-${Environment}-${AWS::AccountId}/*'
      Tags:
        - Key: Project
          Value: !Sub '${ProjectName}'
        - Key: Environment
          Value: !Ref Environment

  EmptyBucketFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-${Environment}-empty-bucket'
      Description: 'Custom resource to empty S3 bucket before CloudFormation deletion'
      Runtime: python3.13
      Handler: index.lambda_handler
      Timeout: 900
      MemorySize: 256
      Role: !GetAtt EmptyBucketLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          s3 = boto3.client('s3')

          def lambda_handler(event, context):
              """
              Custom resource handler to empty S3 bucket on CloudFormation Delete.
              Handles both versioned and non-versioned buckets.
              """
              logger.info(f"Event: {json.dumps(event)}")
              
              try:
                  bucket_name = event['ResourceProperties']['BucketName']
                  request_type = event['RequestType']
                  
                  if request_type == 'Delete':
                      logger.info(f"DELETE request - Emptying bucket: {bucket_name}")
                      empty_bucket(bucket_name)
                      logger.info(f"✅ Successfully emptied bucket: {bucket_name}")
                  elif request_type in ['Create', 'Update']:
                      logger.info(f"{request_type} request - No action needed for bucket: {bucket_name}")
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                      'Message': f'Bucket {bucket_name} processed successfully'
                  })
                  
              except Exception as e:
                  logger.error(f"❌ Error processing bucket: {str(e)}")
                  import traceback
                  traceback.print_exc()
                  cfnresponse.send(event, context, cfnresponse.FAILED, {
                      'Error': str(e)
                  })

          def empty_bucket(bucket_name):
              """
              Delete all objects, versions, and delete markers from the bucket.
              Uses pagination to handle large buckets efficiently.
              """
              try:
                  # Step 1: Delete all object versions and delete markers (for versioned buckets)
                  logger.info(f"Step 1: Deleting object versions and delete markers...")
                  paginator = s3.get_paginator('list_object_versions')
                  
                  try:
                      page_iterator = paginator.paginate(Bucket=bucket_name)
                      
                      for page in page_iterator:
                          objects_to_delete = []
                          
                          # Collect all versions
                          if 'Versions' in page:
                              for version in page['Versions']:
                                  objects_to_delete.append({
                                      'Key': version['Key'],
                                      'VersionId': version['VersionId']
                                  })
                          
                          # Collect all delete markers
                          if 'DeleteMarkers' in page:
                              for marker in page['DeleteMarkers']:
                                  objects_to_delete.append({
                                      'Key': marker['Key'],
                                      'VersionId': marker['VersionId']
                                  })
                          
                          # Delete in batches (max 1000 per request)
                          if objects_to_delete:
                              logger.info(f"Deleting batch of {len(objects_to_delete)} object versions/markers")
                              response = s3.delete_objects(
                                  Bucket=bucket_name,
                                  Delete={'Objects': objects_to_delete, 'Quiet': True}
                              )
                              
                              if 'Errors' in response and response['Errors']:
                                  logger.warning(f"Some objects failed to delete: {response['Errors']}")
                  
                  except s3.exceptions.NoSuchBucket:
                      logger.info(f"Bucket {bucket_name} does not exist, skipping version deletion")
                  
                  # Step 2: Delete any remaining objects (for non-versioned buckets)
                  logger.info(f"Step 2: Deleting remaining objects...")
                  paginator = s3.get_paginator('list_objects_v2')
                  
                  try:
                      page_iterator = paginator.paginate(Bucket=bucket_name)
                      
                      for page in page_iterator:
                          if 'Contents' in page:
                              objects_to_delete = [{'Key': obj['Key']} for obj in page['Contents']]
                              
                              if objects_to_delete:
                                  logger.info(f"Deleting batch of {len(objects_to_delete)} objects")
                                  response = s3.delete_objects(
                                      Bucket=bucket_name,
                                      Delete={'Objects': objects_to_delete, 'Quiet': True}
                                  )
                                  
                                  if 'Errors' in response and response['Errors']:
                                      logger.warning(f"Some objects failed to delete: {response['Errors']}")
                  
                  except s3.exceptions.NoSuchBucket:
                      logger.info(f"Bucket {bucket_name} does not exist, skipping object deletion")
                  
                  logger.info(f"✅ Bucket {bucket_name} emptied successfully")
                  
              except Exception as e:
                  logger.error(f"❌ Error emptying bucket {bucket_name}: {str(e)}")
                  raise
      Tags:
        - Key: Project
          Value: !Sub '${ProjectName}'
        - Key: Environment
          Value: !Ref Environment

  EmptyFrontendBucketOnDelete:
    Type: Custom::EmptyBucket
    Properties:
      ServiceToken: !GetAtt EmptyBucketFunction.Arn
      BucketName: !Ref FrontendBucket

  # CloudFront Origin Access Control
  OriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub '${ProjectName}-${Environment}-oac'
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  # CloudFront Distribution
  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Comment: !Sub '${ProjectName} Frontend Distribution - ${Environment}'
        DefaultCacheBehavior:
          TargetOriginId: !Sub '${ProjectName}-s3-origin'
          ViewerProtocolPolicy: redirect-to-https
          CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6  # Managed-CachingOptimized
          OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf  # Managed-CORS-S3Origin
          ResponseHeadersPolicyId: 67f7725c-6f97-4210-82d7-5512b31e9d03  # Managed-SecurityHeadersPolicy
          Compress: true
        CacheBehaviors:
          # No cache for HTML files
          - PathPattern: "*.html"
            TargetOriginId: !Sub '${ProjectName}-s3-origin'
            ViewerProtocolPolicy: redirect-to-https
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad  # Managed-CachingDisabled
            OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf  # Managed-CORS-S3Origin
            ResponseHeadersPolicyId: 67f7725c-6f97-4210-82d7-5512b31e9d03  # Managed-SecurityHeadersPolicy
            Compress: true
          # No cache for config.json
          - PathPattern: "config.json"
            TargetOriginId: !Sub '${ProjectName}-s3-origin'
            ViewerProtocolPolicy: redirect-to-https
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad  # Managed-CachingDisabled
            OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf  # Managed-CORS-S3Origin
            ResponseHeadersPolicyId: 67f7725c-6f97-4210-82d7-5512b31e9d03  # Managed-SecurityHeadersPolicy
            Compress: true
        DefaultRootObject: index.html
        Enabled: true
        HttpVersion: http2
        IPV6Enabled: true
        Origins:
          - Id: !Sub '${ProjectName}-s3-origin'
            DomainName: !GetAtt FrontendBucket.RegionalDomainName
            OriginAccessControlId: !Ref OriginAccessControl
            S3OriginConfig:
              OriginAccessIdentity: ''
        PriceClass: PriceClass_100  # Use only North America and Europe edge locations
        CustomErrorResponses:
          - ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html
            ErrorCachingMinTTL: 300
          - ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
            ErrorCachingMinTTL: 300
      Tags:
        - Key: Project
          Value: !Sub '${ProjectName}'
        - Key: Environment
          Value: !Ref Environment
        - Key: Purpose
          Value: 'Frontend CDN'

  # S3 Bucket Policy for CloudFront access
  FrontendBucketPolicy:
    Type: AWS::S3::BucketPolicy
    DependsOn: CloudFrontDistribution
    Properties:
      Bucket: !Ref FrontendBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowCloudFrontServicePrincipal
            Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub '${FrontendBucket.Arn}/*'
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub 'arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}'

Outputs:
  FrontendBucketName:
    Description: 'S3 bucket name for frontend static files'
    Value: !Ref FrontendBucket
    Export:
      Name: !Sub '${AWS::StackName}-FrontendBucketName'

  CloudFrontDistributionId:
    Description: 'CloudFront distribution ID'
    Value: !Ref CloudFrontDistribution
    Export:
      Name: !Sub '${AWS::StackName}-CloudFrontDistributionId'

  CloudFrontDomainName:
    Description: 'CloudFront distribution domain name'
    Value: !GetAtt CloudFrontDistribution.DomainName
    Export:
      Name: !Sub '${AWS::StackName}-CloudFrontDomainName'

  FrontendURL:
    Description: 'Frontend application URL'
    Value: !Sub 'https://${CloudFrontDistribution.DomainName}'
    Export:
      Name: !Sub '${AWS::StackName}-FrontendURL'

  S3WebsiteURL:
    Description: 'S3 static website URL (for testing)'
    Value: !GetAtt FrontendBucket.WebsiteURL
    Export:
      Name: !Sub '${AWS::StackName}-S3WebsiteURL'